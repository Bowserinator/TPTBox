#version 430

layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in;

layout(std430, binding = 0) readonly restrict buffer GolRules {
    ivec4 SIMRES;
    uvec2 golRules[];
};
layout(std430, binding = 1) readonly restrict buffer GolInput {
    uint golBuffer[];
};
layout(std430, binding = 2) restrict buffer GolOutput {
    uint golBufferDest[];
};


// (x, y, z) -> array IDX (with wrapping on edges), note edges have 1 padding
uint golIdx(uint x, uint y, uint z) {
    x = (x == 0) ? (SIMRES.x - 2) : (x == SIMRES.x - 1 ? 1 : x);
    y = (y == 0) ? (SIMRES.y - 2) : (y == SIMRES.y - 1 ? 1 : y);
    z = (z == 0) ? (SIMRES.z - 2) : (z == SIMRES.z - 1 ? 1 : z);
    return x + y * SIMRES.x + z * SIMRES.y * SIMRES.x;
}

// Set gol at x, y, z coordinates to value
void setGol(uint x, uint y, uint z, uint value) {
    uint idx = golIdx(x, y, z);
    uint shift = (idx & 3) << 3; // (idx%4) * 8
    golBufferDest[idx >> 2] = (golBufferDest[idx >> 2] & ~uint(255 << shift)) | uint(value << shift);
}

// Return 1 if gol at x, y, z is non-zero, else 0
uint getGol01(uint x, uint y, uint z) {
    uint idx = golIdx(x, y, z);
    return (golBuffer[idx >> 2] & uint(255 << ((idx & 3) << 3))) != 0 ? 1 : 0;
}

// Return actual value at coordinate
uint getGol(uint x, uint y, uint z) {
    uint idx = golIdx(x, y, z);
    uint shift = (idx & 3) << 3;
    return (golBuffer[idx >> 2] & uint(255 << shift)) >> shift;
}


void main() {
    uint x, id, neighborCount;
    uvec2 rule;

    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    for (int dx = 0; dx < 4; dx++) {
        x = 4 * gl_GlobalInvocationID.x + dx;

        if (clamp(ivec3(x, y, z), ivec3(1), SIMRES.xyz - ivec3(2)) != ivec3(x, y, z))
            continue;

        neighborCount = 0;
        id = getGol(x, y, z);
        rule = id == 0 ? golRules[1] : golRules[id - 1];

        // Moore neighborhood
        if ((rule.x & uint(1 << 31)) == 0) {
            neighborCount += getGol01(x - 1, y - 1, z - 1);
            neighborCount += getGol01(x - 1, y - 1, z + 0);
            neighborCount += getGol01(x - 1, y - 1, z + 1);
            neighborCount += getGol01(x - 1, y + 0, z - 1);
            neighborCount += getGol01(x - 1, y + 0, z + 0);
            neighborCount += getGol01(x - 1, y + 0, z + 1);
            neighborCount += getGol01(x - 1, y + 1, z - 1);
            neighborCount += getGol01(x - 1, y + 1, z + 0);
            neighborCount += getGol01(x - 1, y + 1, z + 1);
            neighborCount += getGol01(x + 0, y - 1, z - 1);
            neighborCount += getGol01(x + 0, y - 1, z + 0);
            neighborCount += getGol01(x + 0, y - 1, z + 1);
            neighborCount += getGol01(x + 0, y + 0, z - 1);
            neighborCount += getGol01(x + 0, y + 0, z + 1);
            neighborCount += getGol01(x + 0, y + 1, z - 1);
            neighborCount += getGol01(x + 0, y + 1, z + 0);
            neighborCount += getGol01(x + 0, y + 1, z + 1);
            neighborCount += getGol01(x + 1, y - 1, z - 1);
            neighborCount += getGol01(x + 1, y - 1, z + 0);
            neighborCount += getGol01(x + 1, y - 1, z + 1);
            neighborCount += getGol01(x + 1, y + 0, z - 1);
            neighborCount += getGol01(x + 1, y + 0, z + 0);
            neighborCount += getGol01(x + 1, y + 0, z + 1);
            neighborCount += getGol01(x + 1, y + 1, z - 1);
            neighborCount += getGol01(x + 1, y + 1, z + 0);
            neighborCount += getGol01(x + 1, y + 1, z + 1);
        } else { // Neumann neighborhood
            neighborCount += getGol01(x - 1, y + 0, z + 0);
            neighborCount += getGol01(x + 0, y - 1, z + 0);
            neighborCount += getGol01(x + 0, y + 0, z - 1);
            neighborCount += getGol01(x + 0, y + 0, z + 1);
            neighborCount += getGol01(x + 0, y + 1, z + 0);
            neighborCount += getGol01(x + 1, y + 0, z + 0);
        }

        uint neighborMask = uint(1 << neighborCount);
        if ((rule.x & neighborMask) != 0)
            setGol(x, y, z, 2);
        else if ((rule.y & neighborMask) != 0)
            setGol(x, y, z, id);
        else
            setGol(x, y, z, 0);
    }
}