#version 430

// Multiplication of local sizes <= 1024
layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in;

layout(std430, binding = 0) readonly restrict buffer HeatInput {
    float heatIn[];
};
layout(std430, binding = 1) writeonly restrict buffer HeatOutput {
    float heatOut[];
};
layout(std430, binding = 2) readonly restrict buffer Constants {
    ivec4 SIMRES;
};

uint idx(uint x, uint y, uint z) {
    return x + y * SIMRES.x + z * SIMRES.y * SIMRES.x;
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    uint baseIdx = idx(x, y, z);
    float selfTemp = heatIn[baseIdx];

    if (clamp(ivec3(x, y, z), ivec3(1), SIMRES.xyz - ivec3(2)) != ivec3(x, y, z) || selfTemp < 0.0) {
        heatOut[baseIdx] = -1.0;
        return;
    }

    float total = selfTemp;
    int count = 1;
    float tmp;
    tmp = heatIn[baseIdx - 1];                   if (tmp >= 0.0f) { count++; total += tmp; } // +- x
    tmp = heatIn[baseIdx + 1];                   if (tmp >= 0.0f) { count++; total += tmp; }
    tmp = heatIn[baseIdx - SIMRES.x];            if (tmp >= 0.0f) { count++; total += tmp; } // +- y 
    tmp = heatIn[baseIdx + SIMRES.x];            if (tmp >= 0.0f) { count++; total += tmp; }
    tmp = heatIn[baseIdx + SIMRES.x * SIMRES.y]; if (tmp >= 0.0f) { count++; total += tmp; } // +- z
    tmp = heatIn[baseIdx - SIMRES.x * SIMRES.y]; if (tmp >= 0.0f) { count++; total += tmp; }

    heatOut[baseIdx] = total / float(count);
}